package Lec1_intro;

/**
класс и объект (объект не экземпляр класса)
чем наполняются классы
поведение и состояния - отличия

стихийный подход
процедурный подход
объектно-ориентированный подход

Тезисы ООП:
1. Подучать о том, что мы разрабатываем, а не как.

Реализация только после абстракций
Абстракция, думать не о том как будет работать, а что она будет делать (абстракция - цвет шерсти, породы, кличка, порода).
АБСТРАКЦИЯ - ЧТО ДЕЛАЕТ?
Поведение (играть, спать, бегать, есть).
ПОВЕДЕНИЕ - КАК ДЕЛАЕТ?

Спецификация - набор правил, описывающих API

-------------------------------------------
КЛАСС И ЕГО ЭКЗЕМПЛЯРЫ
Класс - описание сущности, предметнйо области, позволяющей выделить общие хар-ки,
состояние и поведение, зависимое от состояния.
Экземпляр класса - отдельный представитель класса, имеющий конкретное СОСТОЯНИЕ и ПОВЕДЕНИЕ,
которое полностью определяется описанием класса
Состояние - набор данных (полей, атрибутов, членов класса). У экземпляра класса состояния это поля, константы, события.
Поведение - функции для работы с данными и выполнения полезной работы. Для экз. класса это конструкторы, методы.

ООП - это парадигма разработки ПО, основными понятиями которой являются классы и объекты.
Разработка в стиле ООП ведется с использованием классов и объектов, которые обладают состоянием и поведением, зависящем
от этого состояния.
 */

public class oop_intro {

    public static void main(String[] args) {
        Point2D a = new Point2D(0, 2);
        // a.x = 1; //инкапсулировали в класс Point2D значения x и y
        // a.y = 4;
        System.out.println(a.getX());
        System.out.println(a.getY());
        a.setX(12);
        a.setY(3);
        System.out.println(a.getX());
        System.out.println(a.getY());
        Point2D b = new Point2D(2); 
        System.out.println(b.toString());

        Point2D c = new Point2D();
        System.out.println(c.toString());

        var dis = Point2D.distance(a, b); //для статических членов нужно обращаться через имя типа, а не экземпляра
                                          //то есть не a.distance, а сразу Point2D.distance(a, b)
        System.out.println(dis);

        
    }
}

/**
 * Это точка 2D
 */
class Point2D {
    // private int x, y; //блокируем изменение переменных как на чтение так и на запись из внешнего класса
    int x, y;
    //перегрузки в понятиях конструкторов (три подряд конструктора нарушают принцип DRY - dont repeat yourself)
    //есть возможность переиспользования конструкторов
    /**
     * Это конструктор
     * @param valueX координата X
     * @param valueY координата Y
     */
    public Point2D(int valueX, int valueY) { //это пользовательский конструктор
        x = valueX;
        y = valueY;
    }

    // public Point2D() { //конструктор у которого нет аргументов - называется по-умолчанию, переопределяем его
    //     x = 0;
    //     y = 0;
    // }
    
    // public Point2D(int value) { //это пользовательский конструктор
    //     x = value;
    //     y = value;
    // }
    
    public Point2D(int value) {
        this(value, value);  //обращаемся к Point2D в рамках текущего класса
    }

    public Point2D() {
        this(0);  //обращаемся к Point2D c одним аргументов, тот обращается к изначальному конструктору, выполняем DRY
    }

    private String getInfo() { //public - модификатор доступа, private (доступен только внутри класса), protected (скрываем метод)
        return String.format("(%d, %d)", x, y);
    }
    //get и set разграничили функционал доступа
    /**
     * Этот метод задает Х
     * @return
     */
    public int getX() {
        return x;
    }

    public int getY(){
        return y;
    }

    /**
     * Этот метод устанвливает Y
     * @param value
     */
    public void setX(int value) {
        this.x = value; //this не обязателен
    }

    public void setY(int value) {
        this.y = value; //this не обязателен
    }

    //вот это перегрузка методов (метод один и тот же, но сигнатуры разные)
    static double distance(Point2D a, Point2D b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    static double distance(int x1, int x2, int y1, int y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
    //переопределяем поведение класса по-умолчанию
    //переопределение - меняем поведение старого метода под себя, всегда @Override
    //перегрузка - описываем методы одинаковые, но с разной сигнатурой.
    @Override
    public String toString() {
        return getInfo();
    }
}